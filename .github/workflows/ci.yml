name: CI

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review, labeled, edited]
  push:
    branches: [main]
  workflow_dispatch:

concurrency:
  group: ci-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  JAVA_VERSION: "25"                 # configurable
  JACOCO_VERSION: "0.8.12"           # configurable
  PATCH_COVERAGE_MIN: "70"           # configurable (%)
  COVERAGE_XML: "target/site/jacoco/jacoco.xml"
  COVERAGE_REPORT_DIR: "target/site/jacoco"
  DIFF_COVER_MD: "diff-cover.md"
  DIFF_COVER_HTML: "diff-cover.html"

jobs:
  ci:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: ${{ env.JAVA_VERSION }}
          cache: maven

      - name: Unit tests + JaCoCo report (XML)
        run: |
          set -euxo pipefail
          mvn -B -ntp clean \
            org.jacoco:jacoco-maven-plugin:${{ env.JACOCO_VERSION }}:prepare-agent test \
            org.jacoco:jacoco-maven-plugin:${{ env.JACOCO_VERSION }}:report

      - name: Upload test reports (artifact)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: surefire-reports
          path: |
            target/surefire-reports/**
          if-no-files-found: warn

      - name: Upload JaCoCo reports (artifact)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: jacoco-report
          path: |
            ${{ env.COVERAGE_REPORT_DIR }}/**
          if-no-files-found: warn

      - name: Detect coverage override label
        if: github.event_name == 'pull_request'
        id: override
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const labels = (pr.labels || []).map(l => l.name);
            const hasOverride = labels.includes('ci-override-coverage');
            core.setOutput('has_override', hasOverride ? 'true' : 'false');

      - name: Validate override fields (reason/expiry/approver)
        if: github.event_name == 'pull_request' && steps.override.outputs.has_override == 'true'
        run: |
          set -euo pipefail

          BODY="${{ github.event.pull_request.body }}"
          echo "$BODY" > pr_body.txt

          # Require fields in PR template (audit trail)
          grep -qE '^(\*\*Override Coverage Reason:\*\*|Override Coverage Reason:)' pr_body.txt || {
            echo "::error::Missing 'Override Coverage Reason' in PR body."
            exit 1
          }
          grep -qE '^(\*\*Override Coverage Expiry|\*\*Override Coverage Expiry \(YYYY-MM-DD, <= 14 days\):\*\*|Override Coverage Expiry:)' pr_body.txt || {
            echo "::error::Missing 'Override Coverage Expiry' in PR body."
            exit 1
          }
          grep -qE '^(\*\*Override Approver:\*\*|Override Approver:)' pr_body.txt || {
            echo "::error::Missing 'Override Approver' in PR body."
            exit 1
          }

          # Extract expiry date (YYYY-MM-DD)
          EXPIRY=$(grep -E 'Override Coverage Expiry' -n pr_body.txt | head -n1 | sed -E 's/.*([0-9]{4}-[0-9]{2}-[0-9]{2}).*/\1/')
          if ! echo "$EXPIRY" | grep -qE '^[0-9]{4}-[0-9]{2}-[0-9]{2}$'; then
            echo "::error::Override expiry date must be YYYY-MM-DD (found: '$EXPIRY')."
            exit 1
          fi

          TODAY=$(date -u +%F)
          MAX=$(date -u -d "$TODAY +14 days" +%F)

          if [[ "$EXPIRY" < "$TODAY" ]]; then
            echo "::error::Override expiry already passed (expiry=$EXPIRY, today=$TODAY)."
            exit 1
          fi

          if [[ "$EXPIRY" > "$MAX" ]]; then
            echo "::error::Override expiry too long. Must be within 14 days (expiry=$EXPIRY, max=$MAX)."
            exit 1
          fi

          echo "Override expiry validated: $EXPIRY (today=$TODAY, max=$MAX)"

      - name: Setup Python (for diff-cover)
        if: github.event_name == 'pull_request'
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Patch/Diff coverage gate (diff-cover)
        if: github.event_name == 'pull_request'
        run: |
          set -euo pipefail

          # Ensure base branch is available for diff-cover
          BASE_REF="${{ github.base_ref }}"
          git fetch origin "${BASE_REF}:refs/remotes/origin/${BASE_REF}"

          python -m pip install --upgrade pip
          pip install diff-cover

          if [[ ! -f "${{ env.COVERAGE_XML }}" ]]; then
            echo "::error::Coverage XML not found: ${{ env.COVERAGE_XML }}"
            exit 2
          fi

          HAS_OVERRIDE="${{ steps.override.outputs.has_override }}"
          echo "has_override=${HAS_OVERRIDE}" | tee diff-cover.meta

          # Run diff-cover with fail-under gate, and generate reports.
          # If diff coverage < threshold:
          # - fail if no override
          # - pass (with warning) if override label is present
          set +e
          diff-cover "${{ env.COVERAGE_XML }}" \
            --compare-branch "origin/${BASE_REF}" \
            --fail-under="${{ env.PATCH_COVERAGE_MIN }}" \
            --format "markdown:${{ env.DIFF_COVER_MD }},html:${{ env.DIFF_COVER_HTML }}" \
            --exclude "**/generated/**" \
            --total-percent-float \
            --expand-coverage-report \
            2>&1 | tee diff-cover.log
          EXIT_CODE=${PIPESTATUS[0]}
          set -e

          # If report wasn't generated, treat as a hard error (cannot audit)
          if [[ ! -f "${{ env.DIFF_COVER_MD }}" ]]; then
            echo "::error::diff-cover did not generate report. See diff-cover.log"
            exit 2
          fi

          # Add summary to GitHub Actions UI
          {
            echo "## Diff/Patch Coverage"
            echo ""
            echo "- Threshold: **${{ env.PATCH_COVERAGE_MIN }}%**"
            echo "- Override label present: **${HAS_OVERRIDE}**"
            echo ""
            echo "### diff-cover report (markdown)"
            echo ""
            cat "${{ env.DIFF_COVER_MD }}"
          } >> "$GITHUB_STEP_SUMMARY"

          if [[ "${EXIT_CODE}" -ne 0 ]]; then
            if [[ "${HAS_OVERRIDE}" == "true" ]]; then
              echo "::warning::Patch coverage below threshold, but override is approved. (ci-override-coverage)"
              exit 0
            else
              echo "::error::Patch coverage below threshold. Please add tests or request override."
              exit "${EXIT_CODE}"
            fi
          fi

      - name: Upload diff-cover report (artifact)
        if: github.event_name == 'pull_request' && always()
        uses: actions/upload-artifact@v4
        with:
          name: diff-cover-report
          path: |
            diff-cover.log
            diff-cover.meta
            ${{ env.DIFF_COVER_MD }}
            ${{ env.DIFF_COVER_HTML }}
          if-no-files-found: warn

      - name: Comment diff coverage result on PR (audit trail)
        if: github.event_name == 'pull_request' && always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            const pr = context.payload.pull_request;
            const hasOverride = (pr.labels || []).some(l => l.name === 'ci-override-coverage');

            let md = '';
            try { md = fs.readFileSync(process.env.DIFF_COVER_MD, 'utf8'); }
            catch (e) { md = '_diff-cover report not found_'; }

            const marker = '<!-- diff-cover-report -->';
            const body =
`${marker}
### ðŸ§ª CI: Diff/Patch Coverage Report

- Threshold: **${process.env.PATCH_COVERAGE_MIN}%**
- Override label: **${hasOverride ? 'true (ci-override-coverage)' : 'false'}**
- Workflow run: ${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}

<details>
<summary>Report (markdown)</summary>

${md}

</details>
`;

            // Upsert a single comment to avoid spamming
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
            });

            const existing = comments.find(c => c.body && c.body.includes(marker));
            if (existing) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body,
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                body,
              });
            }
        env:
          DIFF_COVER_MD: ${{ env.DIFF_COVER_MD }}
          PATCH_COVERAGE_MIN: ${{ env.PATCH_COVERAGE_MIN }}

      # Optional: Upload coverage to Codecov (solution 1)
      # Enable by adding CODECOV_TOKEN secret (usually required for private repos).
      - name: Upload coverage to Codecov (optional)
        if: always() && (env.CODECOV_ENABLED == 'true')
        uses: codecov/codecov-action@v5
        with:
          fail_ci_if_error: false
          files: ${{ env.COVERAGE_XML }}
          token: ${{ secrets.CODECOV_TOKEN }}
